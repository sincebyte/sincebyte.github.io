[{"authors":[],"categories":[],"content":"如何排查：java.lang.OutOfMemoryError: unable to create native thread\njava.lang.OutOfMemoryError: unable to create native thread 测试代码 for (int i = 0; i \u0026lt; 3500; i++) { new Thread(() -\u0026gt; { try { try {Thread.sleep(5000L);} catch (InterruptedException e) {e.printStackTrace();} TimeUnit.HOURS.sleep(1); log.info(\u0026quot;\\n==== [log]: {} {}\u0026quot;, \u0026quot;sleep over\u0026quot;,Thread.currentThread().getName()); } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } 相关指令 查看进程的线程数量\njstack -l PID | grep 'java.lang.Thread.State' | wc -l jstack -l PID | grep 'java.lang.Thread.State: RUNNABLE' | wc -l jstack -l PID | grep 'java.lang.Thread.State: TIMED_WAITING' | wc -l jstack -l PID | grep 'java.lang.Thread.State: WAITING' | wc -l jstack -l PID | grep 'java.lang.Thread.State:BLOCKED' | wc -l jstack -l PID | grep 'Java-level deadlock' | wc -l 查看进程的线程状态\njstack -l PID | grep 'java.lang.Thread.State' 查看进程的线程信息\njstack -l PID 返回信息，可以看到阻塞的代码信息\n\u0026quot;Thread-4050\u0026quot; #4136 prio=5 os_prio=31 cpu=1.00ms elapsed=546.19s tid=0x0000000130247000 nid=0x354103 waiting on condition [0x00000004b9a2e000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(java.base@11.0.13/Native Method) at java.lang.Thread.sleep(java.base@11.0.13/Thread.java:334) at java.util.concurrent.TimeUnit.sleep(java.base@11.0.13/TimeUnit.java:446) at com.goldkinn.controller.CommentsController$$M$_jr_0E50A6F6C7FE22B0_1 .lambda$0(CommentsController.java:129) at com.goldkinn.controller.CommentsController$$Lambda$964$$M$_jr_0E50A6F6C7FE22B0_1 /0x0000000800e11c40.run(Unknown Source) at java.lang.Thread.run(java.base@11.0.13/Thread.java:829) ","permalink":"/posts/java-oom/","series":[],"tags":[],"title":"java 栈溢出问题排查"},{"authors":[],"categories":[],"content":"RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。\n简介 项目地址：https://github.com/apache/rocketmq/tree/master\nRocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。\n消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。\n架构 NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。\nBroker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。\nProducer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。\nConsumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。\nRocketMQ架构上主要分为四部分，如上图所示:\nProducer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。\nConsumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。\nNameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer和Consumer仍然可以动态感知Broker的路由的信息。\nBrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。\nRemoting Module：整个Broker的实体，负责处理来自Client端的请求。 Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息。 Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。 HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。 Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。 部署 结合部署架构图，描述集群工作流程：\n启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。 Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。 收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。 Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。 Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。 单节点部署 设置环境变量 1 set -x ROCKETMQ_HOME /Users/van/soft/rocketMQ 下载项目至ROCKETMQ_HOME文件目录，\nhttps://github.com/apache/rocketmq/tree/master\n下载项目至ROCKETMQ_HOME文件目录，\nhttps://github.com/apache/rocketmq-dashboard\n启动NameServer 1 nohup sh $ROCKETMQ_HOME/rocketmq-4.9.3/bin/mqnamesrv \u0026amp; 2 tail -f ~/logs/rocketmqlogs/namesrv.log 3 jps 启动borkerServer 1 nohup sh $ROCKETMQ_HOME/rocketmq-4.9.3/bin/mqbroker -n localhost:9876 \u0026amp; 2 tail -f ~/logs/rocketmqlogs/broker.log 3 jps 启动管理端 项目地址：https://github.com/apache/rocketmq-dashboard\n修改nameserver地址，application.yml\n1 ... 2 namesrvAddrs: 3 - 127.0.0.1:9876 4 ... 启动命令\nmvn springboot:run 访问地址：http://localhost:8080/#/topic\n消息发送和消费测试 1 #bash 2 export NAMESRV_ADDR=localhost:9876 3 #fish 4 set -x NAMESRV_ADDR localhost:9876 5 sh $ROCKETMQ_HOME/rocketmq-4.9.3/bin/tools.sh org.apache.rocketmq.example.quickstart.Producer 6 sh $ROCKETMQ_HOME/rocketmq-4.9.3/bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer 复制和刷盘策略 复制策略：同步复制、异步复制，broker master与 slaver 之间数据同步策略\n刷盘策略：同步刷盘、异步刷盘，异步刷盘一般是将数据存储至pageCache,达到一定数量时自动进行落盘\nblocker 集群模式 单Master 只有一个blocker，只能在测试时使用，有单点故障\n多Master broker仅由多个master构成，不存在slaver。同一个topic的各个queue会平均分布至多个master节点。\n优点：配置简单、单个master宕机对集群没影响。前提是需要配置磁盘阵列。raid磁盘阵列的效率要高于master-slaver集群，raid是硬件支持，成本较高。\n缺点：未恢复之前，该机器上的消息不能被消费，消息时时性会受到影响。\n多Master多Slaver-异步复制 master与slaver之间是主备关系，即master负责消息的读写请求，而slaver仅负责消息的备份，mater宕机后的角色自动切换。\n由于是异步负责，在切换过程中可能会涉及少量消息丢失。取决于master向slaver同步数据的时机。\n多Master多Slaver-同步双写 消息写入master后，等待master将信息同步至slaver成功后，返回成功。\n优点：不存在丢失\n缺点：单个消息的RT高，导致性能要略低（约10%），master宕机后不会自动切换至slaver。\nRocketMq工作原理 消息的生产过程 Producer发送消息之前，会先向nameserver请求消息topic的路由信息 nameserver返回该topic的路由表和broker列表\n路由表：map，key为topic名称、value是一个queueData实例列表，即只要涉及到该topic的broker，一个broker对应一个queue,Queuedata中包含brokerName。简单来说，路由表的value为所有涉及该topic的brokerName\nrouterMap\u0026lt;topicName,List\u0026gt;,queueData: brokerName\nBorker列表：Map\u0026lt;brokerName、brokerDataMap\u0026gt;, brokerDataMap\u0026lt;brokerId,brokerIp\u0026gt; Producer根据消息的选择策略，从queue列表中选出一个队列，用于后续存储消息 Producer对消息做一些特殊出理，例如消息超过4M，对消息进行压缩 producer向选择出的queue所在的broker发出rpc请求，将消息发送到选择出的queue queue选择算法 轮询算法，每个queue可均匀收到消息，由于需要等到投递成功后才能进行下个节点的轮询，因此该算法存在在生产者端消息积压问题，影响消息的投递性能。 最小投递延迟算法，将消息投递至延迟最小的queue,可有效提升消息的投递性能。问题是可能出现单机过热，消息分配不均。 消息存储 数据存储在home/store目录下，该目录在启动时创建，正常关闭broker该消息会自动消失，如果启动前发现此文件存在，则说明之前是非正常关闭。 其中存储着commitlog文件，而消息是写在commitlog文件中的 config目录，存放着broker运行期间的一些配置数据 consumequeue, 存储着消费队列 index存储着消息索引文件 lock:运行期间使用到的全局资源锁 commitlog文件 偏移量 索引文件 Reblance 没次新增或者删除消费者的时候都会触发reblance，reblance会导致消息积压和消息重复消费的问题。\n另外如果消费者数量大于queue时，消息只会负载至有限的消费者，这个叫reblance的限制\n","permalink":"/posts/rocketmqintroduction/","series":[],"tags":[],"title":"RocketMQ 必须知道的理论知识"},{"authors":[],"categories":[],"content":"使用 Emacs 导出 html 样式，类似于 doom emacs doc 的 css style\n样式引用：https://docs.doomemacs.org/latest/#/modules\n一个类 doom doc 的 org html 样式模版 点此预览🪄\n使用 配置 snippet 模版，然后在 org mode 文件中使用 tt tab 就可展开此模版。\n# -*- mode: snippet -*- # name: title # key: tt # -- #+title: `(file-name-sans-extension (buffer-name))` #+SUBTITLE: this is subtitle #+AUTHOR: autor #+HTML_HEAD: \u0026lt;script src=\u0026quot;scroll.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; #+HTML_HEAD: \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; href=\u0026quot;org_css.css\u0026quot;/\u0026gt; #+HTML_HEAD: \u0026lt;script src=\u0026quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; #+OPTIONS: prop:nil timestamp:t \\n:t ^:nil f:t toc:t author:t num:t H:2 #+LATEX_COMPILER: xelatex #+LATEX_CLASS: elegantpaper #+MACRO: htmlred @@html:\u0026lt;font color=\u0026quot;red\u0026quot;\u0026gt;\u0026lt;/font\u0026gt;@@ #+MACRO: latexred @@latex:{\\color{red}@@@@latex:}@@ #+latex:\\newpage 想使用在线版的静态文件，可以使用下面的配置进行替换\n#+HTML_HEAD: \u0026lt;link href=\u0026quot;https://emacs-1308440781.cos.ap-chengdu.myqcloud.com/org_css.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt;\u0026lt;/link\u0026gt; #+HTML_HEAD: \u0026lt;script src=\u0026quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; #+HTML_HEAD: \u0026lt;script src=\u0026quot;https://emacs-1308440781.cos.ap-chengdu.myqcloud.com/scroll.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 字体样式 Table 1: 字体样式说明 粗体 bold 斜体 italic 下划线 underlined 中横线 strike-through 代码，按键 code 特殊说明 quote 摘要、引用 可使用`quote`来进行代码块补全，表示摘要，引用\nTECO - Tape [later text] Editor/COrrector\nA combination text editor/really horrible ProgrammingLanguage. To quote the paper “RealProgrammers don’t use Pascal” (1983):\nnotice 注意事项、提醒 你有许多已标记的项目并且你可能错过一个重要的项目时，提醒可以提供帮助\nPlease do not file or answer Doom Emacs issues on Reddit, Twitter, or StackOverflow. Kindly refer them to this section.\n这是 1 个例子\n段落及高亮 Example of an comment.\n原文：用友 bip 产品功能说明 ，在说明文档\n大数据中 最宝贵 、最难以代替的就是数据，一切都围绕数据。\nHDFS 是最早的大数据存储系统，存储着宝贵的数据资产，各种新算法、框架要想得到广泛使用，必须支持 HDFS，才能获取已存储在里面的数据。所以大数据技术越发展，新技术越多，HDFS 得到的支持越多，越离不开 HDFS。HDFS 也许不是最好的大数据存储技术，但依然是最重要的大数据存储技术。\nHDFS 是如何实现大数据高速、可靠的存储和访问的呢？\nHadoop 分布式文件系统 HDFS 的设计目标是管理数以千计的服务器、数以万计的磁盘，将大规模的服务器计算资源当作一个单一存储系统进行管理，对应用程序提供数以 PB 计的存储容量，让应用程序像使用普通文件系统一样存储大规模的文件数据。 表格 C-c ~ to convert to tabel.el table\nC-c ~ to convert to org table\norg table M-h M-l for move Columns left and right\norg table M-k M-j for move Rows up and down\n# table.el for merge Columns or Rows Table 2: square N N^2 N^3 N^4 sqrt(n) sqrt[4](N) 1 1 1 1 1 1 2 4 8 16 1.4142136 1.1892071 3 9 27 81 1.7320508 1.3160740 Table 3: student Student Prob 1 Prob 2 Prob 3 Total Note Maximum 10 15 25 50 10.0 Peter 10 8 23 41 8.2 Sam 2 4 3 9 1.8 Average \u0026#xa0; \u0026#xa0; \u0026#xa0; 25.0 \u0026#xa0; Table 4: long table Format Fine-grained-control Initial Effort Syntax simplicity Editor Support Integrations Ease-of-referencing Versatility Word Word^2 Word^3 Word^4 sqrt(Word) sqrt(sqrt(Word)) 2 2 LaTeX LaTeX^2 LaTeX^3 LaTeX^4 sqrt(LaTeX) sqrt(sqrt(LaTeX)) 4 3 Org Mode Org^2 Mode^2 Org^3 Mode^3 Org^4 Mode^4 sqrt(Org Mode) sqrt(sqrt(Org Mode)) 4 4 Markdown Markdown^2 Markdown^3 Markdown^4 sqrt(Markdown) sqrt(sqrt(Markdown)) 3 1 Markdown + Pandoc (Markdown + Pandoc)^2 (Markdown + Pandoc)^3 (Markdown + Pandoc)^4 sqrt(Markdown + Pandoc) sqrt(sqrt(Markdown + Pandoc)) 3 2 awk 表格 aardvark 555-5553 1200/300 B alpo-net 555-3412 2400/1200/300 A barfly 555-7685 1200/300 A bites 555-1675 2400/1200/300 A camelot 555-0542 300 C core 555-2912 1200/300 C fooey 555-1234 2400/1200/300 B foot 555-6699 1200/300 B macfoo 555-6480 1200/300 A sdace 555-3430 2400/1200/300 A sabafoo 555-2127 1200/300 C /foo/ { print $0 } Table 5: 筛选出 foo 匹配的行 fooey 555-1234 2400/1200/300 B foot 555-6699 1200/300 B macfoo 555-6480 1200/300 A sabafoo 555-2127 1200/300 C 表格自增 id 0 字段名 名称 1 age 年龄 2 bir 出生年月日 #+tblfm: $1=@#-1 C-c C-c to execute it\nLaTex 公式 $\\mbox{需求的价格弹性系数} = \\frac{\\mbox{需求的变动率}}{\\mbox{价格的变动率}}$ $$\\mbox{需求的价格弹性系数} = \\frac{\\mbox{需求的变动率}}{\\mbox{价格的变动率}}$$\n$$\\begin{aligned} \\cos 3\\theta \u0026amp; = \\cos (2 \\theta + \\theta) \\ \u0026amp; = \\cos 2 \\theta \\cos \\theta - \\sin 2 \\theta \\sin \\theta \\ \u0026amp; = (2 \\cos ^2 \\theta -1) \\cos \\theta - (2 \\sin \\theta\\cos \\theta ) \\sin \\theta \\ \u0026amp; = 2 \\cos ^3 \\theta - \\cos \\theta - 2 \\sin ^2 \\theta \\cos \\theta \\ \u0026amp; = 2 \\cos ^3 \\theta - \\cos \\theta - 2 (1 - \\cos ^2 \\theta )\\cos \\theta \\ \u0026amp; = 4 \\cos ^3 \\theta -3 \\cos \\theta \\end{aligned} $$\nOrg 代码 代码片段开启行号，修改 `~/.emacs.d/.local/straight/repos/org/lisp/ox-html.el`\n(let* ((code-lines (split-string code \u0026quot;\\n\u0026quot;)) (code-length (length code-lines)) (num-fmt (and num-start (format \u0026quot;%%%ds \u0026quot; (format \u0026quot;%%%ds: \u0026quot; Java 代码 /** * @param request 调用的请求参数 * @param needLog true 需要记录日志 false 不记录日志 * @return */ protected NcApiResponse runApply(NcApiRequest request, Boolean needLog) { NcApiResponse ncApiResponse = null; try { final NcApiRequest ncApiRequest = executeBefore(request); ncApiResponse = executeGetRequest(ncApiRequest); } catch (Exception e) { afterExecute(needLog, e, request, ncApiResponse); if (e instanceof BizException) { throw new BizException(\u0026quot;NC 提示\u0026quot;, ((BizException) e).getErrorMsg(), e); } else { throw new BizException(\u0026quot;NC 异常\u0026quot;, e.getMessage()); } } return ncApiResponse; } babel java List\u0026lt;Integer\u0026gt; a = Arrays.asList(1, 2); List\u0026lt;Integer\u0026gt; a = Arrays.asList(1, 2); List\u0026lt;Integer\u0026gt; a = Arrays.asList(1, 2); List\u0026lt;Integer\u0026gt; a = Arrays.asList(1, 2); List\u0026lt;Integer\u0026gt; a = Arrays.asList(1, 2); return a; C-c C-c to execute it, but export to html will fail when the babel java result generated.\n图片 引用本地图片 引用网络图片 dot graphviz dot\ndot sk\nplantuml plantuml with style css\nplantuml 替换原生样式\nDARKO RANGE/LIGHTORANGE/DARKBLUE/LIGHTBLUE/DARKRED/LIGHTRED/DARKGREEN/LIGHTGREEN\n!define LIGHTORANGE !includeurl C4-PlantUML/juststyle.puml plant uml 系统 Contex 架构图\nplantuml 替换原生样式\nDARKORANGE/LIGHTORANGE/DARKBLUE/LIGHTBLUE/DARKRED/LIGHTRED/DARKGREEN/LIGHTGREEN\n!define LIGHTBLUE !includeurl C4-PlantUML/juststyle.puml 泳道图\nplantuml htmlstyle\norg 转 Word pandoc -o ~/Desktop/out.docx ~/.doom.d/README.org 插入时间 C-c . 插入当前时间 \u0026lt;2023-02-25 Sat\u0026gt; K lask week J next week L next day ","permalink":"/posts/orgmodecss/","series":[],"tags":[],"title":"推荐一款 org mode 导出 html 的样式"}]